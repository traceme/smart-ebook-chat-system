import json
import subprocess
import logging
import re
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
import pkg_resources
import requests
from packaging import version

logger = logging.getLogger(__name__)

# ============================================================================
# DEPENDENCY VULNERABILITY SCANNER
# ============================================================================

class DependencyScanner:
    """Dependency vulnerability scanner using multiple sources"""
    
    def __init__(self):
        self.vulnerability_db_urls = {
            "pyup": "https://pyup.io/api/v1/vulnerabilities/",
            "osv": "https://osv.dev/v1/query",
            "github": "https://api.github.com/advisories"
        }
        self.cache_duration = timedelta(hours=24)
        self.cache_file = Path(".vulnerability_cache.json")
    
    def scan_dependencies(self, requirements_file: str = "requirements.txt") -> Dict[str, Any]:
        """Scan dependencies for known vulnerabilities"""
        try:
            dependencies = self._parse_requirements(requirements_file)
            vulnerabilities = []
            
            for dep_name, dep_version in dependencies.items():
                vuln_info = self._check_vulnerability(dep_name, dep_version)
                if vuln_info:
                    vulnerabilities.extend(vuln_info)
            
            return {
                "scan_time": datetime.utcnow().isoformat(),
                "dependencies_scanned": len(dependencies),
                "vulnerabilities_found": len(vulnerabilities),
                "vulnerabilities": vulnerabilities,
                "summary": self._generate_vulnerability_summary(vulnerabilities)
            }
            
        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")
            return {"error": str(e)}
    
    def _parse_requirements(self, requirements_file: str) -> Dict[str, str]:
        """Parse requirements.txt file"""
        dependencies = {}
        
        try:
            with open(requirements_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Parse package==version format
                        if '==' in line:
                            package, version_str = line.split('==', 1)
                            dependencies[package.strip()] = version_str.strip()
                        elif '>=' in line:
                            package, version_str = line.split('>=', 1)
                            dependencies[package.strip()] = version_str.strip()
                        else:
                            # Handle other version specifiers
                            package = re.split(r'[<>=!]', line)[0].strip()
                            dependencies[package] = "unknown"
        
        except FileNotFoundError:
            logger.warning(f"Requirements file not found: {requirements_file}")
            # Fall back to installed packages
            dependencies = self._get_installed_packages()
        
        return dependencies
    
    def _get_installed_packages(self) -> Dict[str, str]:
        """Get currently installed packages"""
        dependencies = {}
        
        try:
            for package in pkg_resources.working_set:
                dependencies[package.project_name] = package.version
        except Exception as e:
            logger.error(f"Failed to get installed packages: {e}")
        
        return dependencies
    
    def _check_vulnerability(self, package_name: str, package_version: str) -> List[Dict[str, Any]]:
        """Check package for vulnerabilities"""
        vulnerabilities = []
        
        # Check OSV database
        osv_vulns = self._check_osv_vulnerabilities(package_name, package_version)
        vulnerabilities.extend(osv_vulns)
        
        # Check GitHub Security Advisories
        github_vulns = self._check_github_advisories(package_name, package_version)
        vulnerabilities.extend(github_vulns)
        
        return vulnerabilities
    
    def _check_osv_vulnerabilities(self, package_name: str, package_version: str) -> List[Dict[str, Any]]:
        """Check OSV vulnerability database"""
        vulnerabilities = []
        
        try:
            query = {
                "package": {
                    "name": package_name,
                    "ecosystem": "PyPI"
                },
                "version": package_version
            }
            
            response = requests.post(
                self.vulnerability_db_urls["osv"],
                json=query,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                for vuln in data.get("vulns", []):
                    vulnerabilities.append({
                        "source": "OSV",
                        "id": vuln.get("id"),
                        "package": package_name,
                        "version": package_version,
                        "summary": vuln.get("summary", ""),
                        "details": vuln.get("details", ""),
                        "severity": self._extract_severity(vuln),
                        "cvss_score": self._extract_cvss_score(vuln),
                        "references": vuln.get("references", []),
                        "affected_versions": self._extract_affected_versions(vuln)
                    })
        
        except Exception as e:
            logger.warning(f"Failed to check OSV for {package_name}: {e}")
        
        return vulnerabilities
    
    def _check_github_advisories(self, package_name: str, package_version: str) -> List[Dict[str, Any]]:
        """Check GitHub Security Advisories"""
        vulnerabilities = []
        
        try:
            # GitHub API requires authentication for higher rate limits
            headers = {"Accept": "application/vnd.github.v3+json"}
            
            # Search for advisories affecting this package
            url = f"{self.vulnerability_db_urls['github']}?ecosystem=pip&package={package_name}"
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                advisories = response.json()
                for advisory in advisories:
                    if self._is_version_affected(package_version, advisory.get("vulnerable_version_range", "")):
                        vulnerabilities.append({
                            "source": "GitHub",
                            "id": advisory.get("ghsa_id"),
                            "package": package_name,
                            "version": package_version,
                            "summary": advisory.get("summary", ""),
                            "details": advisory.get("description", ""),
                            "severity": advisory.get("severity", "unknown").lower(),
                            "cvss_score": advisory.get("cvss", {}).get("score"),
                            "references": [ref.get("url") for ref in advisory.get("references", [])],
                            "affected_versions": advisory.get("vulnerable_version_range", "")
                        })
        
        except Exception as e:
            logger.warning(f"Failed to check GitHub advisories for {package_name}: {e}")
        
        return vulnerabilities
    
    def _extract_severity(self, vuln_data: Dict[str, Any]) -> str:
        """Extract severity from vulnerability data"""
        # Try different fields where severity might be stored
        severity_fields = ["severity", "cvss_v3_base_score", "cvss_v2_base_score"]
        
        for field in severity_fields:
            if field in vuln_data:
                return str(vuln_data[field]).lower()
        
        return "unknown"
    
    def _extract_cvss_score(self, vuln_data: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data"""
        cvss_fields = ["cvss_v3_base_score", "cvss_v2_base_score"]
        
        for field in cvss_fields:
            if field in vuln_data:
                try:
                    return float(vuln_data[field])
                except (ValueError, TypeError):
                    continue
        
        return None
    
    def _extract_affected_versions(self, vuln_data: Dict[str, Any]) -> str:
        """Extract affected versions from vulnerability data"""
        if "affected" in vuln_data:
            affected = vuln_data["affected"]
            if isinstance(affected, list) and affected:
                ranges = affected[0].get("ranges", [])
                if ranges:
                    return str(ranges[0])
        
        return "unknown"
    
    def _is_version_affected(self, package_version: str, version_range: str) -> bool:
        """Check if package version is in affected range"""
        try:
            pkg_version = version.parse(package_version)
            
            # Simple range parsing (could be enhanced for more complex ranges)
            if "<" in version_range:
                max_version = version.parse(version_range.split("<")[1].strip())
                return pkg_version < max_version
            elif ">" in version_range:
                min_version = version.parse(version_range.split(">")[1].strip())
                return pkg_version > min_version
            
            return True  # Conservative approach
        
        except Exception:
            return True  # Conservative approach
    
    def _generate_vulnerability_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate summary of vulnerabilities"""
        if not vulnerabilities:
            return {"status": "clean", "message": "No vulnerabilities found"}
        
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "unknown": 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown")
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts["unknown"] += 1
        
        total_vulns = len(vulnerabilities)
        critical_or_high = severity_counts["critical"] + severity_counts["high"]
        
        if critical_or_high > 0:
            status = "critical"
            message = f"Found {critical_or_high} critical/high severity vulnerabilities"
        elif severity_counts["medium"] > 0:
            status = "warning"
            message = f"Found {severity_counts['medium']} medium severity vulnerabilities"
        else:
            status = "info"
            message = f"Found {total_vulns} low severity vulnerabilities"
        
        return {
            "status": status,
            "message": message,
            "severity_breakdown": severity_counts,
            "total_vulnerabilities": total_vulns
        }

# ============================================================================
# VULNERABILITY MANAGEMENT
# ============================================================================

class VulnerabilityManager:
    """Central vulnerability management system"""
    
    def __init__(self):
        self.dependency_scanner = DependencyScanner()
        self.report_file = Path("security_scan_report.json")
    
    def run_dependency_scan(self) -> Dict[str, Any]:
        """Run dependency vulnerability scan"""
        logger.info("Starting dependency vulnerability scan...")
        
        scan_results = {
            "scan_id": hashlib.sha256(f"{datetime.utcnow().isoformat()}dependencies".encode()).hexdigest()[:16],
            "scan_time": datetime.utcnow().isoformat(),
            "scan_type": "dependencies",
            "results": {}
        }
        
        # Run dependency scan
        dep_results = self.dependency_scanner.scan_dependencies()
        scan_results["results"] = dep_results
        
        # Save report
        self._save_report(scan_results)
        
        logger.info("Dependency scan completed")
        return scan_results
    
    def _save_report(self, scan_results: Dict[str, Any]):
        """Save scan report to file"""
        try:
            with open(self.report_file, 'w') as f:
                json.dump(scan_results, f, indent=2, default=str)
            
            logger.info(f"Security scan report saved to {self.report_file}")
        
        except Exception as e:
            logger.error(f"Failed to save scan report: {e}")
    
    def get_latest_report(self) -> Optional[Dict[str, Any]]:
        """Get latest security scan report"""
        try:
            if self.report_file.exists():
                with open(self.report_file, 'r') as f:
                    return json.load(f)
        
        except Exception as e:
            logger.error(f"Failed to load scan report: {e}")
        
        return None

# ============================================================================
# SECURITY TESTING HELPERS
# ============================================================================

def test_password_strength(password: str) -> Dict[str, Any]:
    """Test password strength"""
    from app.core.security import PasswordSecurity
    
    is_valid, errors = PasswordSecurity.validate_password_complexity(password)
    strength = PasswordSecurity.check_password_strength(password)
    
    return {
        "is_valid": is_valid,
        "errors": errors,
        "strength": strength,
        "score": {
            "weak": 1,
            "medium": 2,
            "strong": 3,
            "very_strong": 4
        }.get(strength, 0)
    }

# ============================================================================
# GLOBAL INSTANCES
# ============================================================================

vulnerability_manager = VulnerabilityManager()
dependency_scanner = DependencyScanner() 